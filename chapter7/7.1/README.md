# 7.1 레코드 캡슐화하기

> Encapsulate Record

### 배경

레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 의미 있는 단위로 전달할 수 있게 해준다. 하지만 레코드에는 단점이 있다. 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이 번거롭다.  
반면, 가변 데이터를 저장하는 용도로 객체를 사용하면 어떻게 저장했는지를 숨긴 채 '시작','끝','길이' 를 각각의 메서드로 제공할 수 있다. 사용자는 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요가 없다.

### 절차

1. 레코드를 담은 [변수를 캡슐화][6.6]한다.  
   -> 레코드를 캡슐화하는 함수의 이름은 검색하기 쉽게 지어준다.
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
3. 테스트한다.
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4️⃣에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.  
   -> 중첩된 구조처럼 복잡한 레코드라면, 먼저 데이터를 갱신하는 클라이언트들에 주의해서 살펴본다. 클라이언트가 데이터를 읽기만 한다면 데이터의 복제본이나 읽기전용 프락시를 반환할지 고려해보자.
6. 클래스에서 원본 데이터를 반환하는 접근자와 ( 1️⃣에서 검색하기 쉬운 이름을 붙여둔) 원본 레코드를 반환하는 함수들을 제거한다.
7. 테스트한다.
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 [컬렉션 캡슐화하기][7.2]를 재귀적으로 적용한다.

### 예시

```jsx
organization = { name: '애크미 구스베리', country: 'GB' };
```

---

```jsx
class organization {
  constructor(data) {
    this._name = data.name;
    this._country = data.country;
  }

  get name() {
    return this._name;
  }

  set name(arg) {
    this._name = arg;
  }

  get country() {
    return this._country;
  }

  set country(arg) {
    this._country = arg;
  }
}
```

[6.6]: https://github.com/kse8425/Refactoring/tree/main/chapter6/6.6
[7.2]: https://github.com/kse8425/Refactoring/tree/main/chapter7/7.2
