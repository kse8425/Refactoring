# 10.4 조건부 로직을 다형성으로 바꾸기

> Replace Conditional with Polymorphism

### 배경

복잡한 조건부 로직은 프로그래밍에서 해석하기 가장 난해한 대상에 속한다. 그래서 조건부 로직을 직관적으로 구조화할 방법을 고민해야 한다. 클래스와 다형성을 이용하면 더 확실하게 분리할 수 있다.

예를 들어, 타입을 여러 개 만들고 각 타입이 자신만의 방식으로 로직을 처리하도록 구성하는 방법이 있다. 책,음악,음식은 타입이 다르기 때문에 다르게 처리해야 한다. 이런 경우 case별로 클래스를 하나씩 만들어 공통 switch 로직의 중복을 없앨 수 있다. 다형성을 활용하여 어떻게 동작할지를 각 타입이 알아서 처리하도록 하면 된다.

다른 예로, 기본 동작을 위한 case문과 그 변형 동작으로 구성된 로직을 떠올릴 수 있다. 기본 동작은 가장 일반적이거나 가장 직관적인 동작일 것이다. 먼저 이 로직을 슈퍼클래스로 넣어서 변형 동작에 신경 쓰지 않고 기본에 집중하게 한다. 그런 다음 변형 동작을 뜻하는 case들을 각각의 서브클래스로 만든다. 이 서브클래스들은 기본동작과의 차이를 표현하는 코드로 채워질 것이다.

다형성은 객체 지향 프로그래밍의 핵심이다. 앞서 이야기한 방법들로 개선할 수 있는 복잡한 조건부 로직을 발견하면 다형성이 막강한 도구임을 깨닫게 된다.

### 절차

1. 다형적 동작을 표현하는 클래스들이 아직 없다면 만들어준다. 이왕이면 적합한 인스턴스를 알아서 만들어 반환하는 팩터리 함수도 함께 만든다.
2. 호출하는 코드에서 팩터리 함수를 사용하게 한다.
3. 조건부 로직 함수를 슈퍼클래스로 옮긴다.
   -> 조건부 로직이 온전한 함수로 분리되어 있지 않다면 먼저 함수로 추출한다.
4. 서브클래스 중 하나를 선택한다. 서브클래스에서 슈퍼클래스의 조건부 로직 매서드를 오버라이드한다. 조건부 문장 중 선택된 서브클래스에 해당하는 조건절을 서브클래스 메서드로 복사한 다음 적절히 수정한다.
5. 같은 방식으로 각 조건절을 해당 서브클래스에서 매서드로 구현한다.
6. 슈퍼클래스 메서드에서 기본 동작 부분만 남긴다. 혹은 슈퍼클래스가 추상 클래스여야 한다면, 이 메서드를 추상으로 선언하거나 서브클래스에서 처리해야 함을 알리는 에러를 던진다.

### 예시

```jsx
switch (bird.type) {
  case '유럽 제비':
    return '보통이다';
  case '아프리카 제비':
    return bird.numberOfCoconuts > 2 ? '지쳤다' : '보통이다';
  case '노르웨이 파랑 앵무':
    return bird.voltage > 100 ? '그을렸다' : '예쁘다';
  default:
    return '알 수 없다';
}
```

---

```jsx
class EuropeanSwallow {
    get plumage(){
        return "보통이다"
    }
    ...
}

class AfricanSwallow {
    get plumage () {
        return (this.numberOfCoconuts > 2 ) ? "지쳤다" : "보통이다"
    }
    ...
}

class NorwegianBlueParrot {
    get plumage () {
        return ( this.voltage > 100) ? "그을렸다" : "예쁘다"
    }
    ...
}
```
